import { Observable, OperatorFunction } from "rxjs";
import { Lock } from "./lock";

/**
 * Projects each source value to a Promise which is merged in the output Observable
 * in a serialized fashion waiting for each one to complete before merging the next.
 *
 * @template TIn The type of the elements in the source observable sequence.
 * @template TOut The type of elements in the projected promise sequence.
 * @param {(value: TIn) => Promise<TOut>} projector A function that, when applied to an item emitted by the source Observable, returns a Promise.
 * @returns {OperatorFunction<TIn, TOut>} An operator function that sequences the promises
 * generated by applying the project function to each item emitted by the source Observable.
 */
export function concatMap<TIn, TOut>(projector: (value: TIn) => Promise<TOut>): OperatorFunction<TIn, TOut> {
  return (source: Observable<TIn>) => new Observable(subscriber => {
    let isProcessing = false;
    let queue: Promise<TOut>[] = [];

    const next = (value: TIn) => {
      if (isProcessing) {
        queue.push(projector(value));
      } else {
        isProcessing = true;
        projector(value)
          .then(result => {
            subscriber.next(result);
            isProcessing = false;
            if (queue.length) {
              next(queue.shift() as TIn); // Recursively process queued items
            } else {
              subscriber.complete();
            }
          })
          .catch(error => {
            subscriber.error(error);
            isProcessing = false;
          });
      }
    };

    const subscription = source.subscribe({
      next,
      error: (err: Error) => subscriber.error(err),
      complete: () => {
        if (!queue.length) {
          subscriber.complete();
        }
      },
    });

    return () => {
      subscription.unsubscribe();
    };
  });
}

/**
 * Waits for a condition to be met in an observable stream.
 * @param {Observable<any>} obs - The observable stream to wait for.
 * @param {(value: any) => boolean} predicate - The predicate function to evaluate the values emitted by the observable stream.
 * @returns {Promise<boolean>} A promise that resolves to true when the predicate condition is met, or false if the observable completes without satisfying the predicate.
 */
export function waitFor(obs: Observable<any>, predicate: (value: any) => boolean): Promise<boolean> {
  return new Promise((resolve, reject) => {
    let resolved = false;
    const subscription = obs.subscribe({
      next: value => {
        if (predicate(value) === true) {
          resolved = true;
          resolve(true);
        }
      },
      error: err => reject(err)
    });

    subscription.add(() => {
      if (!resolved) {
        reject(new Error("Promise not resolved."));
      }
      subscription.unsubscribe();
    });
  });
}

/**
 * Projects each source value to a Promise which is merged in the output Observable
 * in a serialized fashion waiting for each one to complete before merging the next.
 *
 * @template T The type of the elements in the source observable sequence.
 * @template R The type of elements in the projected promise sequence.
 * @param {(value: T, index: number) => Promise<R>} project A function that, when applied to an item emitted by the source Observable, returns a Promise.
 * @returns {(source: Observable<T>) => Observable<R>} An operator that sequences the promises
 * generated by applying the project function to each item emitted by the source Observable.
 */
export function sequential<T, R>(project: (value: T, index: number) => Promise<R>): (source: Observable<T>) => Observable<R> {
  let lock = new Lock();

  return (source: Observable<T>) => new Observable<R>(observer => {

    let index = 0;
    const subscription = source.subscribe({
      next(value: any) {
        lock.acquire()
          .then(() => { observer.next(value); return value;})
          .then((value) => project(value, index++))
          .finally(() => lock.release());
      },
      error(err) { observer.error(err); lock.release(); },
      complete() { observer.complete(); lock.release(); }
    });

    return () => {
      subscription.unsubscribe();
    };
  });
}
