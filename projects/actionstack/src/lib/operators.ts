import { CustomObservable, CustomSubject, OperatorFunction, Subscribable } from "./observable";

/**
 * Projects each source value to a Promise which is merged in the output Observable
 * in a serialized fashion waiting for each one to complete before merging the next.
 *
 * @template TIn The type of the elements in the source observable sequence.
 * @template TOut The type of elements in the projected promise sequence.
 * @param {(value: TIn) => Promise<TOut>} projector A function that, when applied to an item emitted by the source Observable, returns a Promise.
 * @returns {OperatorFunction<TIn, TOut>} An operator function that sequences the promises
 * generated by applying the project function to each item emitted by the source Observable.
 */
export function concatMap<T>(projector: (value: T) => Promise<T>) {
  return (source: CustomObservable<T>) => new CustomObservable<T>(subscriber => {
    let isProcessing = false;
    let queue: T[] = [];

    const next = () => {
      if (queue.length > 0 && !isProcessing) {
        isProcessing = true;
        const value = queue.shift()!;
        projector(value)
          .then(result => {
            subscriber.next(result as T);
            isProcessing = false;
            if (queue.length > 0) {
              next();
            }
          })
          .catch(error => {
            subscriber.error(error);
            isProcessing = false;
          });
      }
    };

    const subscription = source.subscribe({
      next: (value: T) => {
        queue.push(value);
        next();
      },
      error: (err: Error) => subscriber.error(err),
      complete: () => {
        if (!queue.length && !isProcessing) {
          subscriber.complete();
        }
      },
    });

    return () => {
      subscription.unsubscribe();
    };
  });
}

/**
 * Concatenates multiple source Observables sequentially.
 *
 * @template T The type of the elements in the source Observables.
 * @param {...Observable<T>[]} sources The source Observables to concatenate.
 * @returns {Observable<T>} An Observable that emits values from the source Observables in order as they are concatenated.
 */
export function concat<T>(...sources: Subscribable<T>[]): Subscribable<T> {
  return new CustomObservable<T>(subscriber => {
    let index = 0;

    const next = () => {
      if (index < sources.length) {
        const source = sources[index++];
        source.subscribe({
          next: value => subscriber.next(value),
          error: error => subscriber.error(error),
          complete: () => next()
        });
      } else {
        subscriber.complete();
      }
    };

    next();
  });
}

/**
 * Combines multiple source Observables into one Observable that emits all the values from each of the source Observables.
 *
 * @template T The type of the elements in the source Observables.
 * @param {...Observable<T>[]} sources The source Observables to merge.
 * @returns {Observable<T>} An Observable that emits all the values from the source Observables.
 */
export function merge<T>(...sources: Subscribable<T>[]): Subscribable<T> {
  return new CustomObservable<T>(subscriber => {
    let completedCount = 0;

    const completeIfAllCompleted = () => {
      if (++completedCount === sources.length) {
        subscriber.complete();
      }
    };

    sources.forEach(source => {
      source.subscribe({
        next: value => subscriber.next(value),
        error: error => subscriber.error(error),
        complete: completeIfAllCompleted
      });
    });
  });
}

/**
 * Waits for a condition to be met in an observable stream.
 * @param {Observable<any>} obs - The observable stream to wait for.
 * @param {(value: any) => boolean} predicate - The predicate function to evaluate the values emitted by the observable stream.
 * @returns {Promise<boolean>} A promise that resolves to true when the predicate condition is met, or false if the observable completes without satisfying the predicate.
 */
export function waitFor(obs: Subscribable<any>, predicate: (value: any) => boolean): Promise<boolean> {
  return new Promise((resolve, reject) => {
    let hasValueEmitted = false; // Flag to track if a value has been emitted
    const value = (obs as CustomSubject<any>)?.value;

    if(value !== undefined) {
      resolve(value);
    }

    const subscription = obs.subscribe({
      next: value => {
        if (!hasValueEmitted && predicate(value)) {
          hasValueEmitted = true;
          subscription.unsubscribe();
          resolve(value);
        }
      },
      error: err => reject(err),
      complete: () => {
        if (!hasValueEmitted) {
          reject(new Error("Predicate not met before completion"));
        }
      },
    });

    return () => {
      subscription.unsubscribe();
    };
  });
}

/**
 * A custom observable operator that starts tracking the time.
 * @param {function} callback - The callback function to call when tracking starts.
 * @returns {OperatorFunction<any, any>} The operator function.
 */
export function startTracking(callback: (startTime: number) => void): OperatorFunction<any, any> {
  return source => source.pipe(
    tap(() => {
      if (typeof performance !== 'undefined' && performance.now) {
        const startTime = performance.now();
        callback(startTime);
      }
    })
  );
}

/**
 * A custom observable operator that finishes tracking the time.
 * @param {function} callback - The callback function to call when tracking finishes.
 * @returns {OperatorFunction<any, any>} The operator function.
 */
export function finishTracking(callback: (endTime: number) => void): OperatorFunction<any, any> {
  return source => new CustomObservable<any>(observer => {
    const subscription = source.subscribe({
      async next(value) {
        await observer.next(value);
        if (typeof performance !== 'undefined' && performance.now) {
          const endTime = performance.now();
          callback(endTime);
        }
      },
      error(err) {
        observer.error(err);
      },
      complete() {
        observer.complete();
      }
    });

    // Unsubscribe on unsubscribe
    return () => subscription.unsubscribe();
  });
}

/**
 * Creates an observable that mirrors the source observable with an additional
 * side effect function `onExecuted` executed after each emitted value.
 * @param {Observable} source The source observable to mirror.
 * @param {Function} onExecuted The function to execute after each value is emitted.
 * @returns {Observable} The new observable with the side effect.
 */
export function withStatusTracking(onExecuted = () => {}): OperatorFunction<any, any> {
  return source => new CustomObservable<any>(observer => {
    const subscription = source.subscribe({
      async next(value) {
        await observer.next(value);
        onExecuted();
      },
      error(err) {
        observer.error(err);
      },
      complete() {
        observer.complete();
      }
    });

    // Unsubscribe on unsubscribe
    return () => subscription.unsubscribe();
  });
}

